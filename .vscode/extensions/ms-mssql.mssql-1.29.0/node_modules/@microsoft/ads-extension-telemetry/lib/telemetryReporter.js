"use strict";
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const extension_telemetry_1 = require("@vscode/extension-telemetry");
const timedAction_1 = require("./timedAction");
/**
 * List of domain names that we use to determine if a user is internal to Microsoft.
 */
const msftInternalDomains = [
    "redmond.corp.microsoft.com",
    "northamerica.corp.microsoft.com",
    "fareast.corp.microsoft.com",
    "ntdev.corp.microsoft.com",
    "wingroup.corp.microsoft.com",
    "southpacific.corp.microsoft.com",
    "wingroup.windeploy.ntdev.microsoft.com",
    "ddnet.microsoft.com",
    "europe.corp.microsoft.com"
];
/**
 * Attempts to determine whether this machine is an MSFT internal user. This is not 100% accurate and isn't
 * meant to be, but is good enough for our cases.
 * @returns true if internal, false otherwise
 */
function isMsftInternal() {
    // Original logic from https://github.com/Microsoft/azuredatastudio/blob/9a14fef8075965f62c2d4efdfa1a30bf6ddddcf9/src/vs/platform/telemetry/common/telemetryUtils.ts#L260
    // This is a best-effort guess using the DNS domain for the user
    const userDnsDomain = process.env['USERDNSDOMAIN'];
    if (!userDnsDomain) {
        return false;
    }
    const domain = userDnsDomain.toLowerCase();
    return msftInternalDomains.some(msftDomain => domain === msftDomain);
}
const commonMeasurements = {
    // Use a number since that's what ADS core uses.
    // NOTE: We do NOT set the UTC flag like core
    // (https://github.com/Microsoft/azuredatastudio/blob/9a14fef8075965f62c2d4efdfa1a30bf6ddddcf9/src/vs/platform/telemetry/common/1dsAppender.ts#L53)
    // since we don't have direct access to the internal appender instance and currently the package
    // only sets that flag is "telemetry.internalTesting" is true
    // https://github.com/microsoft/vscode-extension-telemetry/blob/04e50fbc94a922f5e2ee6eb2cf2236491f1f99d9/src/common/1dsClientFactory.ts#L52
    'common.msftInternal': isMsftInternal() ? 1 : 0
};
const commonProperties = {};
try {
    const azdata = require('azdata');
    commonProperties['common.adsversion'] = azdata === null || azdata === void 0 ? void 0 : azdata.version;
}
catch (err) {
    // no-op when we're not in a context that has azdata available
}
class TelemetryEventImpl {
    constructor(reporter, eventName, properties, measurements) {
        this.reporter = reporter;
        this.eventName = eventName;
        this.properties = properties;
        this.measurements = measurements;
        this.properties = properties || {};
        Object.assign(this.properties, commonProperties);
        this.measurements = measurements || {};
        Object.assign(this.measurements, commonMeasurements);
    }
    send() {
        var _a;
        try {
            (_a = this.reporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(this.eventName, this.properties, this.measurements);
        }
        catch (e) {
            // We don't want exceptions sending telemetry to break extensions so just log and ignore
            const msg = e instanceof Error ? e.message : e;
            console.error(`Error sending ${this.eventName} event ${msg}`);
        }
    }
    withAdditionalProperties(additionalProperties) {
        Object.assign(this.properties, additionalProperties);
        return this;
    }
    withAdditionalMeasurements(additionalMeasurements) {
        Object.assign(this.measurements, additionalMeasurements);
        return this;
    }
    withConnectionInfo(connectionInfo) {
        // IMPORTANT - If making changes here the same changes should generally be made in the AdsTelemetryService version as well
        // Safeguard against invalid objects being passed in
        if (typeof connectionInfo === 'object') {
            Object.assign(this.properties, {
                authenticationType: connectionInfo.authenticationType,
                providerName: connectionInfo.providerName
            });
        }
        else {
            console.error(`AdsTelemetryReporter received invalid ConnectionInfo object of type ${typeof connectionInfo}`);
        }
        return this;
    }
    withServerInfo(serverInfo) {
        // IMPORTANT - If making changes here the same changes should generally be made in the AdsTelemetryService version as well
        var _a, _b, _c;
        // Safeguard against invalid objects being passed in
        if (typeof serverInfo === 'object') {
            Object.assign(this.properties, {
                connectionType: serverInfo.isCloud !== undefined ? (serverInfo.isCloud ? 'Azure' : 'Standalone') : '',
                serverVersion: (_a = serverInfo.serverVersion) !== null && _a !== void 0 ? _a : '',
                serverEdition: (_b = serverInfo.serverEdition) !== null && _b !== void 0 ? _b : '',
                serverEngineEdition: (_c = serverInfo.engineEditionId) !== null && _c !== void 0 ? _c : ''
            });
        }
        else {
            console.error(`AdsTelemetryReporter received invalid ServerInfo object of type ${typeof serverInfo}`);
        }
        return this;
    }
}
class TelemetryReporter {
    /**
     *
     * @param extensionId The ID of the extension sending the event
     * @param extensionVersion The version of the extension sending the event
     * @param key The AI Key to use
     */
    constructor(extensionId, extensionVersion, key) {
        var _a, _b;
        this._telemetryReporter = undefined;
        // Try to initialize the reporter, but don't throw if it fails so we don't break the extension
        try {
            this._telemetryReporter = new extension_telemetry_1.default(extensionId, extensionVersion, key);
        }
        catch (e) {
            console.error(`Error initializing TelemetryReporter for '${extensionId}'. ${(_b = (_a = e) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : e}`);
        }
    }
    /**
     * Creates a View event that can be sent later. This is used to log that a particular page or item was seen.
     * @param view The name of the page or item that was viewed
     */
    createViewEvent(view) {
        return new TelemetryEventImpl(this._telemetryReporter, 'view', {
            view: view
        });
    }
    /**
     * Sends a View event. This is used to log that a particular page or item was seen.
     * @param view The name of the page or item that was viewed
     */
    sendViewEvent(view) {
        this.createViewEvent(view).send();
    }
    /**
     * Creates an Action event that can be sent later. This is used to log when an action was taken, such as clicking a button.
     * @param view The name of the page or item where this action occurred
     * @param action The name of the action taken
     * @param target The name of the item being acted on
     * @param source The source of the action
     * @param durationInMs The duration the action took to execute
     */
    createActionEvent(view, action, target = '', source = '', durationInMs) {
        const measures = durationInMs ? { durationInMs: durationInMs } : {};
        return new TelemetryEventImpl(this._telemetryReporter, 'action', {
            view: view,
            action: action,
            target: target,
            source: source
        }, measures);
    }
    /**
     * Sends a Action event. This is used to log when an action was taken, such as clicking a button.
     * @param view The name of the page or item where this action occurred
     * @param action The name of the action taken
     * @param target The name of the item being acted on
     * @param source The source of the action
     * @param durationInMs The duration the action took to execute
     */
    sendActionEvent(view, action, target = '', source = '', durationInMs) {
        this.createActionEvent(view, action, target, source, durationInMs).send();
    }
    /**
     * Creates a TimedAction - which will create and send an action event with a duration when send() is called. The timer
     * starts on construction and ends when send() is called.
     * @param view The view this action originates from
     * @param action The name of the action
     * @param target The name of the item being acted on
     * @param source The source of the action
     * @returns The TimedAction object
     */
    createTimedAction(view, action, target, source) {
        return new timedAction_1.TimedAction(this, view, action, target, source);
    }
    /**
     * Creates a Metrics event that can be sent later. This is used to log measurements taken.
     * @param measurements The metrics to send
     * @param groupName The name of the group these measurements belong to
     */
    createMetricsEvent(measurements, groupName = '') {
        return new TelemetryEventImpl(this._telemetryReporter, 'metrics', { groupName: groupName }, measurements);
    }
    /**
     * Sends a Metrics event. This is used to log measurements taken.
     * @param measurements The measurements to send
     * @param groupName The name of the group these measurements belong to
     */
    sendMetricsEvent(measurements, groupName = '') {
        this.createMetricsEvent(measurements, groupName).send();
    }
    /**
     * Creates a new Error event that can be sent later. This is used to log errors that occur.
     * @param view The name of the page or item where the error occurred
     * @param name The friendly name of the error
     * @param errorCode The error code returned
     * @param errorType The specific type of error
     * @deprecated Use createErrorEvent2
     */
    createErrorEvent(view, name, errorCode = '', errorType = '') {
        return new TelemetryEventImpl(this._telemetryReporter, 'error', {
            view: view,
            name: name,
            errorCode: errorCode,
            errorType: errorType
        });
    }
    /**
     * Sends a Error event. This is used to log errors that occur.
     * @param view The name of the page or item where the error occurred
     * @param name The friendly name of the error
     * @param errorCode The error code returned
     * @param errorType The specific type of error
     * @deprecated Use sendErrorEvent2
     */
    sendErrorEvent(view, name, errorCode = '', errorType = '') {
        this.createErrorEvent(view, name, errorCode, errorType).send();
    }
    /**
     * Creates a new Error event that can be sent later. This is used to log errors that occur.
     * @param view The name of the page or item where the error occurred
     * @param name The friendly name of the error
     * @param error The error. If an Error object the message and stack will be extracted and added to the event, otherwise the message will be set to error.toString()
     * @param includeMessage Whether the error message is included. This can often contain sensitive information, so by default is false. Only set to true if you're absolutely sure there will be no sensitive information included.
     * @param errorCode The error code returned, default is empty
     * @param errorType The specific type of error, default is empty
     */
    createErrorEvent2(view, name, error = undefined, includeMessage = false, errorCode = '', errorType = '') {
        const props = {
            view: view,
            name: name,
            errorCode: errorCode,
            errorType: errorType
        };
        if (error instanceof Error) {
            props.message = includeMessage === true ? error.message : '';
            let stack = error.stack || '';
            // Stack trace contains the message, so remove it if we aren't set to include it
            if (includeMessage !== true && error.message) {
                const regex = new RegExp(error.message, 'g');
                stack = stack.replace(regex, '<REDACTED: error-message>');
            }
            props.stack = stack;
        }
        else {
            props.message = includeMessage === true ? error === null || error === void 0 ? void 0 : error.toString() : '';
            props.stack = '';
        }
        return new TelemetryEventImpl(this._telemetryReporter, 'error', props);
    }
    /**
     * Sends a Error event. This is used to log errors that occur.
     * @param view The name of the page or item where the error occurred
     * @param name The friendly name of the error
     * @param error The error object. If an Error object the message and stack will be extracted and added to the event, otherwise the message will be set to error.toString()
     * @param includeMessage Whether the error message is included. This can often contain sensitive information, so by default is false. Only set to true if you're absolutely sure there will be no sensitive information included.
     * @param errorCode The error code returned
     * @param errorType The specific type of error
     */
    sendErrorEvent2(view, name, error = undefined, includeMessage = false, errorCode = '', errorType = '') {
        this.createErrorEvent2(view, name, error, includeMessage, errorCode, errorType).send();
    }
    /**
     * Creates a custom telemetry event with the specified name that can be sent later. Generally the other send functions should be
     * preferred over this - only use this if you absolutely need a custom event that can't be covered by the other methods.
     * @param eventName The name of the event. Will be prefixed with <extension-name>/
     * @param properties The list of properties to send along with the event
     * @param measurements The list of measurements to send along with the event
     */
    createTelemetryEvent(eventName, properties, measurements) {
        return new TelemetryEventImpl(this._telemetryReporter, eventName, properties, measurements);
    }
    /**
     * Sends a custom telemetry event with the specified name. Generally the other send functions should be
     * preferred over this - only use this if you absolutely need a custom event that can't be covered by the other
     * @param eventName The name of the event. Will be prefixed with <extension-name>/
     * @param properties The list of properties to send along with the event
     * @param measurements The list of measurements to send along with the event
     */
    sendTelemetryEvent(eventName, properties, measurements) {
        this.createTelemetryEvent(eventName, properties, measurements).send();
    }
    /**
     * Disposes of the telemetry reporter. This flushes the remaining events and disposes of the telemetry client.
     */
    dispose() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_a = this._telemetryReporter) === null || _a === void 0 ? void 0 : _a.dispose());
        });
    }
}
exports.default = TelemetryReporter;
//# sourceMappingURL=telemetryReporter.js.map
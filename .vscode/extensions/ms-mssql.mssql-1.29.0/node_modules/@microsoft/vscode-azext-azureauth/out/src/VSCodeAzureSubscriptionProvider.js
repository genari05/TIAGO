"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VSCodeAzureSubscriptionProvider = void 0;
const vscode = require("vscode");
const NotSignedInError_1 = require("./NotSignedInError");
const getSessionFromVSCode_1 = require("./getSessionFromVSCode");
const configuredAzureEnv_1 = require("./utils/configuredAzureEnv");
const EventDebounce = 5 * 1000; // 5 seconds
/**
 * A class for obtaining Azure subscription information using VSCode's built-in authentication
 * provider.
 */
class VSCodeAzureSubscriptionProvider extends vscode.Disposable {
    constructor() {
        const disposable = vscode.authentication.onDidChangeSessions((e) => __awaiter(this, void 0, void 0, function* () {
            // Ignore any sign in that isn't for the configured auth provider
            if (e.provider.id !== (0, configuredAzureEnv_1.getConfiguredAuthProviderId)()) {
                return;
            }
            if (yield this.isSignedIn()) {
                if (!this.suppressSignInEvents && Date.now() > this.lastSignInEventFired + EventDebounce) {
                    this.lastSignInEventFired = Date.now();
                    this.onDidSignInEmitter.fire();
                }
            }
            else if (Date.now() > this.lastSignOutEventFired + EventDebounce) {
                this.lastSignOutEventFired = Date.now();
                this.onDidSignOutEmitter.fire();
            }
        }));
        super(() => {
            this.onDidSignInEmitter.dispose();
            this.onDidSignOutEmitter.dispose();
            disposable.dispose();
        });
        this.onDidSignInEmitter = new vscode.EventEmitter();
        this.lastSignInEventFired = 0;
        this.suppressSignInEvents = false;
        this.onDidSignOutEmitter = new vscode.EventEmitter();
        this.lastSignOutEventFired = 0;
        /**
         * An event that is fired when the user signs in. Debounced to fire at most once every 5 seconds.
         */
        this.onDidSignIn = this.onDidSignInEmitter.event;
        /**
         * An event that is fired when the user signs out. Debounced to fire at most once every 5 seconds.
         */
        this.onDidSignOut = this.onDidSignOutEmitter.event;
    }
    /**
     * Gets a list of tenants available to the user.
     * Use {@link isSignedIn} to check if the user is signed in to a particular tenant.
     *
     * @returns A list of tenants.
     */
    getTenants() {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const { client } = yield this.getSubscriptionClient();
            const results = [];
            try {
                for (var _d = true, _e = __asyncValues(client.tenants.list()), _f; _f = yield _e.next(), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const tenant = _c;
                        results.push(tenant);
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return results;
        });
    }
    /**
     * Gets a list of Azure subscriptions available to the user.
     *
     * @param filter - Whether to filter the list returned, according to the list returned
     * by `getTenantFilters()` and `getSubscriptionFilters()`. Optional, default true.
     *
     * @returns A list of Azure subscriptions.
     *
     * @throws A {@link NotSignedInError} If the user is not signed in to Azure.
     * Use {@link isSignedIn} and/or {@link signIn} before this method to ensure
     * the user is signed in.
     */
    getSubscriptions(filter = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const tenantIds = yield this.getTenantFilters();
            const shouldFilterTenants = filter && !!tenantIds.length; // If the list is empty it is treated as "no filter"
            const results = [];
            try {
                this.suppressSignInEvents = true;
                // Get the list of tenants
                for (const tenant of yield this.getTenants()) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const tenantId = tenant.tenantId;
                    // If filtering is enabled, and the current tenant is not in that list, then skip it
                    if (shouldFilterTenants && !tenantIds.includes(tenantId)) {
                        continue;
                    }
                    // If the user is not signed in to this tenant, then skip it
                    if (!(yield this.isSignedIn(tenantId))) {
                        continue;
                    }
                    // For each tenant, get the list of subscriptions
                    results.push(...yield this.getSubscriptionsForTenant(tenantId));
                }
            }
            finally {
                this.suppressSignInEvents = false;
            }
            const sortSubscriptions = (subscriptions) => subscriptions.sort((a, b) => a.name.localeCompare(b.name));
            const subscriptionIds = yield this.getSubscriptionFilters();
            if (filter && !!subscriptionIds.length) { // If the list is empty it is treated as "no filter"
                return sortSubscriptions(results.filter(sub => subscriptionIds.includes(sub.subscriptionId)));
            }
            return sortSubscriptions(results);
        });
    }
    /**
     * Checks to see if a user is signed in.
     *
     * @param tenantId (Optional) Provide to check if a user is signed in to a specific tenant.
     *
     * @returns True if the user is signed in, false otherwise.
     */
    isSignedIn(tenantId) {
        return __awaiter(this, void 0, void 0, function* () {
            const session = yield (0, getSessionFromVSCode_1.getSessionFromVSCode)([], tenantId, { createIfNone: false, silent: true });
            return !!session;
        });
    }
    /**
     * Asks the user to sign in or pick an account to use.
     *
     * @param tenantId (Optional) Provide to sign in to a specific tenant.
     *
     * @returns True if the user is signed in, false otherwise.
     */
    signIn(tenantId) {
        return __awaiter(this, void 0, void 0, function* () {
            const session = yield (0, getSessionFromVSCode_1.getSessionFromVSCode)([], tenantId, { createIfNone: true, clearSessionPreference: true });
            return !!session;
        });
    }
    /**
     * Signs the user out
     *
     * @deprecated Not currently supported by VS Code auth providers
     */
    signOut() {
        throw new Error(vscode.l10n.t('Signing out programmatically is not supported. You must sign out by selecting the account in the Accounts menu and choosing Sign Out.'));
    }
    /**
     * Gets the tenant filters that are configured in `azureResourceGroups.selectedSubscriptions`. To
     * override the settings with a custom filter, implement a child class with `getSubscriptionFilters()`
     * and/or `getTenantFilters()` overridden.
     *
     * If no values are returned by `getTenantFilters()`, then all tenants will be scanned for subscriptions.
     *
     * @returns A list of tenant IDs that are configured in `azureResourceGroups.selectedSubscriptions`.
     */
    getTenantFilters() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = vscode.workspace.getConfiguration('azureResourceGroups');
            const fullSubscriptionIds = config.get('selectedSubscriptions', []);
            return fullSubscriptionIds.map(id => id.split('/')[0]);
        });
    }
    /**
     * Gets the subscription filters that are configured in `azureResourceGroups.selectedSubscriptions`. To
     * override the settings with a custom filter, implement a child class with `getSubscriptionFilters()`
     * and/or `getTenantFilters()` overridden.
     *
     * If no values are returned by `getSubscriptionFilters()`, then all subscriptions will be returned.
     *
     * @returns A list of subscription IDs that are configured in `azureResourceGroups.selectedSubscriptions`.
     */
    getSubscriptionFilters() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = vscode.workspace.getConfiguration('azureResourceGroups');
            const fullSubscriptionIds = config.get('selectedSubscriptions', []);
            return fullSubscriptionIds.map(id => id.split('/')[1]);
        });
    }
    /**
     * Gets the subscriptions for a given tenant.
     *
     * @param tenantId The tenant ID to get subscriptions for.
     *
     * @returns The list of subscriptions for the tenant.
     */
    getSubscriptionsForTenant(tenantId) {
        var _a, e_2, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const { client, credential, authentication } = yield this.getSubscriptionClient(tenantId);
            const environment = (0, configuredAzureEnv_1.getConfiguredAzureEnv)();
            const subscriptions = [];
            try {
                for (var _d = true, _e = __asyncValues(client.subscriptions.list()), _f; _f = yield _e.next(), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const subscription = _c;
                        subscriptions.push({
                            authentication: authentication,
                            environment: environment,
                            credential: credential,
                            isCustomCloud: environment.isCustomCloud,
                            /* eslint-disable @typescript-eslint/no-non-null-assertion */
                            name: subscription.displayName,
                            subscriptionId: subscription.subscriptionId,
                            /* eslint-enable @typescript-eslint/no-non-null-assertion */
                            tenantId: tenantId,
                        });
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return subscriptions;
        });
    }
    /**
     * Gets a fully-configured subscription client for a given tenant ID
     *
     * @param tenantId (Optional) The tenant ID to get a client for
     *
     * @returns A client, the credential used by the client, and the authentication function
     */
    getSubscriptionClient(tenantId, scopes) {
        return __awaiter(this, void 0, void 0, function* () {
            const armSubs = yield Promise.resolve().then(() => require('@azure/arm-resources-subscriptions'));
            const session = yield (0, getSessionFromVSCode_1.getSessionFromVSCode)(scopes, tenantId, { createIfNone: false, silent: true });
            if (!session) {
                throw new NotSignedInError_1.NotSignedInError();
            }
            const credential = {
                getToken: () => __awaiter(this, void 0, void 0, function* () {
                    return {
                        token: session.accessToken,
                        expiresOnTimestamp: 0
                    };
                })
            };
            const configuredAzureEnv = (0, configuredAzureEnv_1.getConfiguredAzureEnv)();
            const endpoint = configuredAzureEnv.resourceManagerEndpointUrl;
            return {
                client: new armSubs.SubscriptionClient(credential, { endpoint }),
                credential: credential,
                authentication: {
                    getSession: () => session,
                    getSessionWithScopes: (scopes) => {
                        return (0, getSessionFromVSCode_1.getSessionFromVSCode)(scopes, tenantId, { createIfNone: false, silent: true });
                    },
                }
            };
        });
    }
}
exports.VSCodeAzureSubscriptionProvider = VSCodeAzureSubscriptionProvider;
//# sourceMappingURL=VSCodeAzureSubscriptionProvider.js.map